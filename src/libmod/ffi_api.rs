/*! Get the true bounding box size that fits a Windows ğŸ–°mouse cursor=pointer using 2 methods:
  1. GetCursorInfo â†’ GetIconInfo APIs that extracts nominal cursor size that is adjusted by screen DPI, but not adjusted for user accessibility multiplier, and them manually does the approximate adjustment for it. But does NOT take into account cursor shadow.
  2. DirectX duplication API that captures a screenshot and extracts mouse cursor from it. Takes into account all size-related factors: monitor scaling, user accessibility multiplier, cursor shadow.

  See win_api_const.ahk for an example on how to use in AutoHotkey
*/

use crate::libmod::ffi_api::std::mem;
use crate::libmod::*;


use widestring::WideChar;


use std     	::{self,ptr};

use windows::Win32::UI::WindowsAndMessaging::{CURSORINFO,HCURSOR,CURSOR_SHOWING,};
use windows::Win32::UI::WindowsAndMessaging::GetCursorInfo;
use windows::Win32::Foundation::POINT;


pub fn cur_box_to_screen(cbox:&mut cur_box, hs_screen: &POINT) {
  let icon_box_x = hs_screen.x - cbox.hs.x;
  let icon_box_y = hs_screen.y - cbox.hs.y;
  cbox.ptl.x += icon_box_x;
  cbox.ptl.y += icon_box_y;
  cbox.pbr.x += icon_box_x;
  cbox.pbr.y += icon_box_y;
  cbox.hs.x  = hs_screen.x;
  cbox.hs.y  = hs_screen.y;
}

use docpos::*;

#[unsafe(no_mangle)] pub extern "C"
fn get_mcursor_sz_ci(mut cur_box:cur_box, coord:i8) -> ğ‘ğ‘  {
  // 1 ğŸ–° Global cursor (GetCursorInfo) even if it's not owned by the current thread
  // 1.1 Get handle to the cursor itself
  let mut curâ„¹ = CURSORINFO {cbSize: mem::size_of::<CURSORINFO>() as u32, ..Default::default()};
    /*hCursor:HCURSOR   cbSize:u32 (!must set before! ??? becomes 0 after GetCursorInfo call)
    flags      :CURSORINFO_FLAGS	0=hidden 1=CURSOR_SHOWING 2=CURSOR_SUPPRESSED (touch/pen)
    ptScreenPos:POINT           	screen coordinates of the cursor*/
  let res = unsafe { GetCursorInfo(&mut curâ„¹) }; if res.is_err()                 {cur_box=cur_box::default(); return ffiğ‘’("âœ— Couldn't â€˜GetCursorInfoâ€™!"            )}
  let cur_h:HCURSOR = curâ„¹.hCursor;              if curâ„¹.flags != CURSOR_SHOWING {cur_box=cur_box::default(); return ffiğ‘’("âœ— cursor is not shown (hidden or touch/pen)!")}

  // 1.2 Get/parse handle(s) to the cursor bitmap mask(s)
  let coords = parse_cursor_h(cur_h, false,&[]);
  match coords {
    Ok(mut c)	=> {if coord == Coord::Mon as i8 {cur_box_to_screen(&mut c, &curâ„¹.ptScreenPos)}; cur_box=c; ffiğ‘’("")},
    Err(ğ‘’)   	=> {ffiğ‘’(format!("âœ— Couldn't get ğŸ–° cursor size box parsing bitmaps from â€˜GetCursorInfoâ€™ â†’ â€˜GetIconInfoâ€™! ğ‘’ = â€˜{}â€™",ğ‘’))},
  }
}

#[unsafe(no_mangle)] pub extern "C"
fn get_mcursor_sz_dx(mut cur_box:cur_box, coord:i8) -> ğ‘ğ‘  {
  // 2 DXGI duplication API (screenshot the whole screen, get pointer image). Unlike â†‘ captures shadow
  match get_mptr_sz(None,&[]) {
    Ok(mut c) => {
      if coord == Coord::Mon as i8 { //convert to screen coordinates once we get hotspot's screen coords
        let cur_pos = POINT {x:c.hs.x, y:c.hs.y};
        cur_box_to_screen(&mut c, &cur_pos);
      };
      cur_box = c;
      ffiğ‘’("")
    },
    Err(ğ‘’)  => {ffiğ‘’(format!("{ğ‘’}"))},
  }
}

type ğ‘ğ‘  = *mut WideChar;
use widestring::U16CString;

#[docpos]
fn ffiğ‘’( /// Return an FFI-friendly error string to a non-Rust caller
  ///! Rust error string vallue to return. â— Must be deallocated via `dealloc_lib_string` to avoid memory leak (can't be deallocated by the caller)
  s: impl AsRef<str>,) -> ğ‘ğ‘  { if s.as_ref().is_empty() {ptr::null_mut()} else {
    U16CString::from_str(s).map(U16CString::into_raw)
    .unwrap_or_else(|_ğ‘’|{// eprintln!("Error, `s` returned a string with inner null bytes: {}", ğ‘’);
      ptr::null_mut()    }) //todoâ†‘ print to win debug log
}}

/** # SAFETY
  Must be called only with a pointer generated by another Rust function via `.into_raw`. The pointer can't be used after this call, and the FFI receiver of this pointer can't edit it*/
#[unsafe(no_mangle)] pub unsafe extern "system"
fn dealloc_lib_string(ğ‘:ğ‘ğ‘ ) {unsafe {
  if !ğ‘.is_null() { drop::<U16CString>(U16CString::from_raw(ğ‘)); }
}}
